from pyControl.hardware import IO_object, assign_ID, interrupt_queue
import pyControl.framework as fw
import pyControl.state_machine as sm


class Crossing:
    above = "above"
    below = "below"
    none = "none"


class SchmittTrigger(IO_object):
    """
    Generates framework events when an analog signal goes above an upper threshold and/or below a lower threshold.
    The rising event is triggered when signal > upper bound, falling event is triggered when signal < lower bound.

    This trigger implements hysteresis, which is a technique to prevent rapid oscillations or "bouncing" of events:
    - Hysteresis creates a "dead zone" between the upper and lower thresholds
    - Once a rising event is triggered (when signal crosses above the upper bound),
      it cannot be triggered again until the signal has fallen below the lower bound
    - Similarly, once a falling event is triggered (when signal crosses below the lower bound),
      it cannot be triggered again until the signal has risen above the upper bound

    This behavior is particularly useful for noisy signals that might otherwise rapidly cross a single threshold
    multiple times, generating unwanted repeated events.
    """

    def __init__(self, bounds, rising_event=None, falling_event=None):
        if rising_event is None and falling_event is None:
            raise ValueError("Either rising_event or falling_event or both must be specified.")
        self.rising_event = rising_event
        self.falling_event = falling_event
        self.bounds = bounds
        self.timestamp = 0
        assign_ID(self)

    def run_start(self):
        self.set_bounds(self.bounds)

    def set_bounds(self, threshold):
        if isinstance(threshold, tuple):
            threshold_requirements_str = "The threshold must be a tuple of two integers (lower_bound, upper_bound) where lower_bound <= upper_bound."
            if len(threshold) != 2:
                raise ValueError("{} is not a valid threshold. {}".format(threshold, threshold_requirements_str))
            lower, upper = threshold
            if not upper >= lower:
                raise ValueError(
                    "{} is not a valid threshold because the lower bound {} is greater than the upper bound {}. {}".format(
                        threshold, lower, upper, threshold_requirements_str
                    )
                )
            self.upper_threshold = upper
            self.lower_threshold = lower
        else:
            raise ValueError("{} is not a valid threshold. {}".format(threshold, threshold_requirements_str))
        self.reset_crossing = True

        fw.data_output_queue.put(
            fw.Datatuple(
                fw.current_time,
                fw.PRINT_TYP,
                "s",
                "({}, {}) bounds = ({},{})".format(
                    self.rising_event, self.falling_event, self.upper_threshold, self.lower_threshold
                ),
            )
        )

    def _initialise(self):
        # Set event codes for rising and falling events.
        self.rising_event_ID = sm.events[self.rising_event] if self.rising_event in sm.events else False
        self.falling_event_ID = sm.events[self.falling_event] if self.falling_event in sm.events else False
        self.threshold_active = self.rising_event_ID or self.falling_event_ID

    def _process_interrupt(self):
        # Put event generated by threshold crossing in event queue.
        if self.was_above:
            fw.event_queue.put(fw.Datatuple(self.timestamp, fw.EVENT_TYP, "i", self.rising_event_ID))
        else:
            fw.event_queue.put(fw.Datatuple(self.timestamp, fw.EVENT_TYP, "i", self.falling_event_ID))

    @micropython.native
    def check(self, sample):
        if self.reset_crossing:
            # this gets run when the first sample is taken and whenever the threshold is changed
            self.reset_crossing = False
            self.was_above = sample > self.upper_threshold
            self.was_below = sample < self.lower_threshold
            self.last_crossing = Crossing.none
            return
        is_above_threshold = sample > self.upper_threshold
        is_below_threshold = sample < self.lower_threshold

        if is_above_threshold and not self.was_above and self.last_crossing != Crossing.above:
            self.timestamp = fw.current_time
            self.last_crossing = Crossing.above
            if self.rising_event_ID:
                interrupt_queue.put(self.ID)
        elif is_below_threshold and not self.was_below and self.last_crossing != Crossing.below:
            self.timestamp = fw.current_time
            self.last_crossing = Crossing.below
            if self.falling_event_ID:
                interrupt_queue.put(self.ID)

        self.was_above, self.was_below = is_above_threshold, is_below_threshold
